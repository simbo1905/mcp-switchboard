import { readFileSync, existsSync } from 'fs';
import * as path from 'path';

// Enhanced contract verification that works without nightly Rust
function verifyBindings(): boolean {
  const bindingsPath = '../mcp-switchboard-ui/src/bindings.ts';
  
  if (!existsSync(bindingsPath)) {
    console.error(`‚ùå Bindings file not found: ${bindingsPath}`);
    return false;
  }

  const bindingsContent = readFileSync(bindingsPath, 'utf-8');
  
  console.log(`üìä Contract Verification:`);
  
  // Check file size (should not be empty or too small)
  if (bindingsContent.length < 100) {
    console.error(`   ‚ùå Bindings file too small: ${bindingsContent.length} chars`);
    return false;
  }
  
  // Check for required header information
  const hasHeader = bindingsContent.includes('Generated by binding-generator from mcp-core types');
  const hasBuildFingerprint = bindingsContent.includes('Build fingerprint:');
  const hasNoMockFunctions = bindingsContent.includes('NO MOCK FUNCTIONS');
  
  if (!hasHeader) {
    console.error(`   ‚ùå Missing proper header in bindings file`);
    return false;
  }
  
  if (!hasBuildFingerprint) {
    console.error(`   ‚ùå Missing build fingerprint in bindings file`);
    return false;
  }
  
  if (!hasNoMockFunctions) {
    console.error(`   ‚ùå Missing 'NO MOCK FUNCTIONS' declaration`);
    return false;
  }
  
  // Check for core expected types from mcp-core
  const expectedTypes = [
    'ModelInfo',
    'ApiError', 
    'ChatStreamPayload',
    'ChatErrorPayload',
    'BuildInfo',
    'DependencyInfo',
    'StreamMessage'
  ];
  
  let foundTypes = 0;
  expectedTypes.forEach(type => {
    if (bindingsContent.includes(`export interface ${type}`) || 
        bindingsContent.includes(`export type ${type}`)) {
      foundTypes++;
      console.log(`   ‚úÖ Found type: ${type}`);
    } else {
      console.warn(`   ‚ö†Ô∏è  Type possibly missing: ${type}`);
    }
  });
  
  // Check for proper export structure
  const hasExports = bindingsContent.includes('export interface') || bindingsContent.includes('export type');
  if (!hasExports) {
    console.error(`   ‚ùå No TypeScript exports found`);
    return false;
  }
  
  // Count lines and interfaces for statistics  
  const lines = bindingsContent.split('\n').length;
  const interfaceCount = (bindingsContent.match(/export interface/g) || []).length;
  const typeCount = (bindingsContent.match(/export type/g) || []).length;
  
  console.log(`   üìà Statistics:`);
  console.log(`      - Lines: ${lines}`);
  console.log(`      - Interfaces: ${interfaceCount}`);
  console.log(`      - Type aliases: ${typeCount}`);
  console.log(`      - Expected types found: ${foundTypes}/${expectedTypes.length}`);
  
  // Verify the build fingerprint format
  const fingerprintMatch = bindingsContent.match(/Build fingerprint: ([a-f0-9-]+)/);
  if (fingerprintMatch) {
    console.log(`   üîç Build fingerprint: ${fingerprintMatch[1]}`);
  }
  
  // Basic success criteria
  const hasMinimumTypes = foundTypes >= (expectedTypes.length * 0.7); // At least 70% of expected types
  const hasReasonableSize = bindingsContent.length > 500; // At least 500 chars
  const hasValidStructure = hasHeader && hasBuildFingerprint && hasNoMockFunctions;
  
  if (hasMinimumTypes && hasReasonableSize && hasValidStructure) {
    console.log(`‚úÖ Contract verification passed!`);
    console.log(`   - File structure: valid`);
    console.log(`   - Type coverage: ${foundTypes}/${expectedTypes.length} (${Math.round(foundTypes/expectedTypes.length*100)}%)`);
    console.log(`   - File size: ${bindingsContent.length} chars`);
    return true;
  } else {
    console.error(`‚ùå Contract verification failed!`);
    if (!hasMinimumTypes) {
      console.error(`   - Insufficient type coverage: ${foundTypes}/${expectedTypes.length}`);
    }
    if (!hasReasonableSize) {
      console.error(`   - File too small: ${bindingsContent.length} chars`);
    }
    if (!hasValidStructure) {
      console.error(`   - Invalid file structure`);
    }
    return false;
  }
}

// Run verification
try {
  const success = verifyBindings();
  process.exit(success ? 0 : 1);
} catch (error) {
  console.error(`‚ùå Contract verification error:`, error);
  process.exit(1);
}