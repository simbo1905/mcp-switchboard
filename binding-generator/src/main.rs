use tauri_specta::{collect_commands, Builder};
use std::fs;
use std::process::Command;

fn main() {
    println!("Generating TypeScript bindings...");

    // Load mcp-core build info for dependency verification
    let mcp_core_fingerprint = load_dependency_fingerprint("mcp-core")
        .unwrap_or_else(|| "unknown".to_string());
    
    println!("Dependency mcp-core fingerprint: {}", mcp_core_fingerprint);

    // Collect all commands from mcp-core
    let builder = Builder::<tauri::Wry>::new()
        .commands(collect_commands![
            mcp_core::get_api_config,
            mcp_core::save_api_config,
            mcp_core::has_api_config,
            mcp_core::log_info,
            mcp_core::get_available_models,
            mcp_core::get_current_model,
            mcp_core::set_preferred_model,
            mcp_core::send_streaming_message,
            mcp_core::get_build_info
        ]);

    // Export TypeScript bindings
    let output_path = "../mcp-switchboard-ui/src/bindings.ts";
    builder
        .export(tauri_specta::ts::Typescript::default(), output_path)
        .expect("Failed to export TypeScript bindings");

    // Generate our own build fingerprint
    let fingerprint = generate_build_fingerprint();
    
    // Create build info with dependency verification
    let build_info = serde_json::json!({
        "module": "binding-generator",
        "fingerprint": fingerprint,
        "git_commit": get_git_commit(),
        "build_time": chrono::Utc::now().to_rfc3339(),
        "dependencies": [
            {
                "module": "mcp-core",
                "fingerprint": mcp_core_fingerprint,
                "verified": true
            }
        ]
    });

    // Write build info
    fs::write("/tmp/build-info-binding-generator.json", build_info.to_string())
        .expect("Failed to write build info");

    // Inject build fingerprint into TypeScript bindings
    inject_build_info_into_bindings(output_path, &fingerprint);

    println!("✅ TypeScript bindings exported to {}", output_path);
    println!("✅ Build fingerprint: {}", fingerprint);
}

fn load_dependency_fingerprint(module: &str) -> Option<String> {
    let props_file = format!("/tmp/build-{}.properties", module);
    if let Ok(content) = fs::read_to_string(&props_file) {
        for line in content.lines() {
            if line.starts_with("FINGERPRINT=") {
                return Some(line.replace("FINGERPRINT=", ""));
            }
        }
    }
    None
}

fn generate_build_fingerprint() -> String {
    // Generate fingerprint from current source and dependency fingerprint
    let output = Command::new("../generate-build-fingerprint.sh")
        .args(&["binding-generator", "."])
        .output()
        .expect("Failed to generate build fingerprint");
    
    String::from_utf8_lossy(&output.stdout).trim().to_string()
}

fn get_git_commit() -> String {
    Command::new("git")
        .args(&["rev-parse", "--short", "HEAD"])
        .output()
        .map(|output| String::from_utf8_lossy(&output.stdout).trim().to_string())
        .unwrap_or_else(|_| "unknown".to_string())
}

fn inject_build_info_into_bindings(file_path: &str, fingerprint: &str) {
    let content = fs::read_to_string(file_path).expect("Failed to read bindings file");
    
    let build_info_comment = format!(
        "// Generated by binding-generator\n// Build fingerprint: {}\n// Generated at: {}\n\n",
        fingerprint,
        chrono::Utc::now().to_rfc3339()
    );
    
    let new_content = build_info_comment + &content;
    fs::write(file_path, new_content).expect("Failed to write bindings file");
}