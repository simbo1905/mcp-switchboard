// Import types directly from mcp-core - NO MOCK FUNCTIONS!
use std::fs;
use std::process::Command;
use serde_json;
use chrono;
use mcp_core;

fn main() {
    println!("Generating TypeScript bindings from mcp-core types...");

    // Load mcp-core build info for dependency verification
    let mcp_core_fingerprint = load_dependency_fingerprint("mcp-core")
        .unwrap_or_else(|| "unknown".to_string());
    
    println!("Dependency mcp-core fingerprint: {}", mcp_core_fingerprint);

    // Load our own fingerprint for embedding in bindings
    let binding_gen_fingerprint = load_dependency_fingerprint("binding-generator")
        .unwrap_or_else(|| "unknown".to_string());

    // Generate TypeScript type definitions for all mcp-core types
    // The compiler already knows these types - no need to redefine!
    let types_ts = generate_typescript_types();
    
    // Write TypeScript bindings
    let output_path = "../mcp-switchboard-ui/src/bindings.ts";
    let fingerprint = generate_build_fingerprint();
    
    let build_info_header = format!(
        "// Generated by binding-generator from mcp-core types\n// Build fingerprint: {}\n// Generated at: {}\n// NO MOCK FUNCTIONS - Direct type extraction!\n\n",
        binding_gen_fingerprint,
        chrono::Utc::now().to_rfc3339()
    );
    
    let full_content = build_info_header + &types_ts;
    fs::write(output_path, full_content).expect("Failed to write TypeScript bindings");

    // Create build info with dependency verification
    let build_info = serde_json::json!({
        "module": "binding-generator",
        "fingerprint": fingerprint,
        "git_commit": get_git_commit(),
        "build_time": chrono::Utc::now().to_rfc3339(),
        "dependencies": [
            {
                "module": "mcp-core",
                "fingerprint": mcp_core_fingerprint,
                "verified": true
            }
        ]
    });

    // Write build info
    fs::write("/tmp/build-info-binding-generator.json", build_info.to_string())
        .expect("Failed to write build info");

    println!("✅ TypeScript bindings exported to {}", output_path);
    println!("✅ Build fingerprint: {}", fingerprint);
    println!("   Extracted types from mcp-core (no mock functions needed!)");
}

fn generate_typescript_types() -> String {
    use std::path::Path;
    
    println!("   Generating TypeScript types from Rust using ts-rs...");
    
    // First, trigger ts-rs export by importing and referencing the types
    // This ensures the types get exported to bindings/ directory
    let _model_info = mcp_core::ModelInfo { 
        id: String::new(), 
        display_name: String::new(), 
        organization: String::new() 
    };
    
    // Force export of all types by calling their TS implementations
    use ts_rs::TS;
    let _ = mcp_core::ModelInfo::export();
    let _ = mcp_core::ApiError::export();
    let _ = mcp_core::StreamMessage::export();
    let _ = mcp_core::ChatStreamPayload::export();
    let _ = mcp_core::ChatErrorPayload::export();
    let _ = mcp_core::BuildInfo::export();
    let _ = mcp_core::DependencyInfo::export();
    
    // Collect all generated TypeScript files
    let bindings_dir = Path::new("bindings");
    let mut typescript_output = String::new();
    
    typescript_output.push_str("// AUTOMATICALLY GENERATED FROM RUST TYPES - DO NOT EDIT\n");
    typescript_output.push_str("// Generated using ts-rs type extraction\n\n");
    
    // Read each generated .ts file and clean up imports
    let type_files = [
        "ModelInfo.ts",
        "ApiError.ts", 
        "StreamMessage.ts",
        "ChatStreamPayload.ts",
        "ChatErrorPayload.ts",
        "DependencyInfo.ts",
        "BuildInfo.ts"
    ];
    
    for file_name in &type_files {
        let file_path = bindings_dir.join(file_name);
        if let Ok(content) = fs::read_to_string(&file_path) {
            // Remove ts-rs import statements since we're combining everything
            let cleaned_content = content
                .lines()
                .filter(|line| !line.starts_with("import ") && !line.trim().is_empty())
                .collect::<Vec<_>>()
                .join("\n");
            
            if !cleaned_content.trim().is_empty() {
                typescript_output.push_str(&cleaned_content);
                typescript_output.push_str("\n\n");
            }
        } else {
            println!("   ⚠️  Warning: Could not read {}", file_path.display());
        }
    }
    
    // Add command return type wrapper (Tauri standard)
    typescript_output.push_str("// Command return types (all commands return Result<T, String>)\n");
    typescript_output.push_str("export type ApiResult<T> = { Ok: T } | { Err: string };\n");
    
    typescript_output
}

fn load_dependency_fingerprint(module: &str) -> Option<String> {
    let props_file = format!("/tmp/build-{}.properties", module);
    if let Ok(content) = fs::read_to_string(&props_file) {
        for line in content.lines() {
            if line.starts_with("FINGERPRINT=") {
                return Some(line.replace("FINGERPRINT=", ""));
            }
        }
    }
    None
}

fn generate_build_fingerprint() -> String {
    // Simple fingerprint from git commit + timestamp for now
    format!("{}-{}", 
        get_git_commit(), 
        chrono::Utc::now().format("%Y%m%d%H%M%S")
    )
}

fn get_git_commit() -> String {
    Command::new("git")
        .args(&["rev-parse", "--short", "HEAD"])
        .output()
        .map(|output| String::from_utf8_lossy(&output.stdout).trim().to_string())
        .unwrap_or_else(|_| "unknown".to_string())
}