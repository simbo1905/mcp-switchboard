use serde::{Deserialize, Serialize};

/// Build information with embedded constants generated at compile time
#[derive(Serialize, Deserialize, Clone)]
pub struct BuildInfo {
    pub module: String,
    pub fingerprint: String,
    pub git_commit: String,
    pub git_headline: String,
    pub build_time: String,
    pub dependencies: Vec<DependencyInfo>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct DependencyInfo {
    pub module: String,
    pub fingerprint: String,
    pub verified: bool,
}

/// Embedded build constants generated by build.rs
pub mod embedded {
    /// Module name
    pub const MODULE: &str = "mcp-core";
    
    // Conditional compilation for embedded constants vs fallback
    #[cfg(not(feature = "no-embed"))]
    mod build_constants {
        /// Git commit hash (short)
        pub const GIT_COMMIT: &str = include_str!(concat!(env!("OUT_DIR"), "/git_commit.txt"));
        /// Git commit headline  
        pub const GIT_HEADLINE: &str = include_str!(concat!(env!("OUT_DIR"), "/git_headline.txt"));
        /// Build timestamp in RFC3339 format
        pub const BUILD_TIME: &str = include_str!(concat!(env!("OUT_DIR"), "/build_time.txt"));
        /// Build fingerprint (SHA256 of all source files)
        pub const FINGERPRINT: &str = include_str!(concat!(env!("OUT_DIR"), "/fingerprint.txt"));
    }
    
    #[cfg(feature = "no-embed")]
    mod build_constants {
        pub const GIT_COMMIT: &str = "unknown";
        pub const GIT_HEADLINE: &str = "unknown";
        pub const BUILD_TIME: &str = "unknown";
        pub const FINGERPRINT: &str = "development";
    }
    
    pub use build_constants::*;
}

impl BuildInfo {
    /// Create BuildInfo from embedded constants (preferred method)
    pub fn from_embedded() -> Self {
        BuildInfo {
            module: embedded::MODULE.to_string(),
            fingerprint: embedded::FINGERPRINT.trim().to_string(),
            git_commit: embedded::GIT_COMMIT.trim().to_string(),
            git_headline: embedded::GIT_HEADLINE.trim().to_string(),
            build_time: embedded::BUILD_TIME.trim().to_string(),
            dependencies: vec![], // mcp-core has no dependencies
        }
    }
    
    /// Load build info from file (fallback method)
    pub fn load() -> anyhow::Result<BuildInfo> {
        // Try embedded constants first
        let embedded_info = Self::from_embedded();
        if embedded_info.fingerprint != "unknown" && embedded_info.git_commit != "unknown" {
            return Ok(embedded_info);
        }
        
        // Fallback to file-based loading
        let build_info_path = "/tmp/build-info-mcp-core.json";
        if std::path::Path::new(build_info_path).exists() {
            let data = std::fs::read_to_string(build_info_path)?;
            let build_info: BuildInfo = serde_json::from_str(&data)?;
            Ok(build_info)
        } else {
            // Final fallback for development
            Ok(BuildInfo {
                module: "mcp-core".to_string(),
                fingerprint: "development".to_string(),
                git_commit: "unknown".to_string(),
                git_headline: "unknown".to_string(),
                build_time: "unknown".to_string(),
                dependencies: vec![],
            })
        }
    }
    
    pub fn log_startup_info(&self) {
        log::info!("=== MCP-CORE BUILD INFO ===");
        log::info!("Module: {}", self.module);
        log::info!("Build fingerprint: {}", self.fingerprint);
        log::info!("Git commit: {}", self.git_commit);
        log::info!("Git headline: {}", self.git_headline);
        log::info!("Build time: {}", self.build_time);
        log::info!("Dependencies verified: {}", self.dependencies.iter().all(|d| d.verified));
        log::info!("========================");
    }
}